Recursion in C++ is a programming technique where a function **calls itself** directly or indirectly to solve a problem. It's commonly used to solve problems that can be broken down into **smaller, similar subproblems**, like factorial calculation, Fibonacci series, tree traversal, etc.

---

### üîÅ Basic Structure of a Recursive Function

Every recursive function has:
1. **Base case(s)** ‚Äì condition(s) under which the function stops calling itself.
2. **Recursive case(s)** ‚Äì part where the function calls itself with modified arguments.

---

### üìå Example 1: Factorial of a number

```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0) return 1; // Base case
    return n * factorial(n - 1); // Recursive call
}

int main() {
    int n = 5;
    cout << "Factorial of " << n << " is: " << factorial(n);
    return 0;
}
```

üß† This will output:  
`Factorial of 5 is: 120`

---

### üìå Example 2: Fibonacci Series

```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n == 0) return 0; // Base case
    if (n == 1) return 1; // Base case
    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive call
}

int main() {
    int n = 6;
    cout << "Fibonacci(" << n << ") is: " << fibonacci(n);
    return 0;
}
```

üß† This will output:  
`Fibonacci(6) is: 8`

---

### üîç Pros and Cons of Recursion

**‚úÖ Advantages:**
- Elegant and clean code for problems like tree/graph traversal.
- Easier to write for divide-and-conquer problems.

**‚ùå Disadvantages:**
- Uses more memory (stack frames).
- Can be slower than iteration if not optimized.
- May cause stack overflow for deep recursion.

---

### üìö Bonus Tip: Tail Recursion

A tail-recursive function is one where the recursive call is the **last thing** done. C++ compilers can optimize it to avoid additional stack frames (though not always guaranteed like in functional languages).

---

